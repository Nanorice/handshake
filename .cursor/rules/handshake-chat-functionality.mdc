---
description: 
globs: 
alwaysApply: false
---
# Chat Functionality - Requirements & Planning Document (RPD)

## 🧭 Feature Purpose
Enable seamless, real-time, persistent chat between Seekers and Professionals once a connection is mutually accepted. Chat aims to replicate a clean, professional experience similar to LinkedIn's messaging, with a focus on usability, moderation, and reliability.

---

## 🔄 Feature Flow

1. **Connection-Based Access**:
   - Chat is unlocked only after a Professional accepts a Seeker's invitation.
   - A chat thread is automatically initialized and stored in the system.

2. **Chat Interface**:
   - Available both as a standalone route (`/messages`) and a floating panel on the bottom-right corner of any page (LinkedIn-style).
   - In-app notifications for new messages appear in both interfaces.

---

## 📦 Functional Requirements

- Real-time messaging between connected users.
- Persistent message history (no expiration).
- Support for sending PDF attachments.
- Reply to specific messages (threaded reply style).
- In-app notification system for new messages.
- Chat moderation system (report/block).
- Rate limiting to prevent spam.
- Continuous conversation thread (no session-based separation).

---

## 🧱 System Design

- **Service-Based**: Chat logic isolated as a service (e.g., `chat.service.js`) decoupled from the rest of the business logic.
- **Socket Layer**: Abstracted using a centralized event bus with `Socket.IO`.
- **Modular Controllers**: Split by feature — message, thread, moderation.

---

## 🏗️ Architecture Pattern

- **Client-Server + Real-Time Socket Layer**
  - RESTful APIs for fetching chat threads, metadata.
  - Socket.IO for real-time messaging.
- **Event-driven Micro-Modules**: For extensibility and testability.

---

## 🧠 State Management

- **Client-side**: React Context or Zustand to manage open chats, message history, unread counters, etc.
- **Server-side**: Stateless API + stateful socket channels.

---

## 🔁 Data Flow

1. Seeker sends invite ➝ Professional accepts ➝ Backend creates a `Thread` document.
2. Both users can now:
   - Emit messages via socket.
   - Receive real-time updates on the other end.
   - Fetch previous chat history via REST API.
3. Notifications emitted via socket + stored in Notification DB.

---

## 🧰 Technical Stack

- **Frontend**: React.js + Tailwind CSS + Zustand
- **Backend**: Node.js (Express)
- **Database**: MongoDB + Mongoose
- **Real-Time**: Socket.IO
- **File Storage**: Cloud storage (e.g., AWS S3 or Cloudinary) for PDF uploads
- **Notifications**: Mongo-backed, possibly Redis-pubsub if scaling
- **Encryption**: NaCl or AES for E2E encryption layer (future milestone)

---

## 🔐 Authentication Process

- JWT-based auth headers required for both HTTP and WebSocket handshake.
- Token verified upon each socket connection.

---

## 🌐 Route Design

### HTTP Endpoints
- `GET /chat/threads`: List all chat threads for current user
- `GET /chat/threads/:id`: Get full message history for a thread
- `POST /chat/message`: Send a message (fallback for offline)
- `POST /chat/report`: Report a message/user
- `POST /chat/block`: Block a user

### Socket Events
- `chat:join` – Authenticate and join rooms
- `chat:send` – Emit message
- `chat:receive` – Listen for new messages
- `chat:typing` – Optional typing event
- `chat:notification` – Notify on new message

---

## 🗃️ Database Design ERD

### User
- _id
- name
- role (Seeker/Professional)
- blockedUsers: [UserID]

### Thread
- _id
- userA: UserID
- userB: UserID
- messages: [MessageID]
- createdAt

### Message
- _id
- threadId: ThreadID
- sender: UserID
- type: "text" | "pdf"
- content: String
- timestamp: Date
- replyTo: MessageID (optional)
- status: "sent" | "received"

### Notification
- _id
- userId
- type: "chat"
- messagePreview
- threadId
- createdAt
- read: Boolean

### Report
- _id
- reportedBy: UserID
- targetUser: UserID
- messageId: MessageID (optional)
- reason: String
- status: "open" | "resolved"

---

## 🛡️ Moderation & Rate Limiting

- Middleware checks for message frequency (e.g., max 10 messages per minute).
- Manual report interface for admins to view flagged content.
- Users can block other users — blocks both messaging and notifications.

