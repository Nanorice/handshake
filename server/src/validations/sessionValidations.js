const { z } = require('zod');

const mongoIdRegex = /^[0-9a-fA-F]{24}$/;

const sessionIdParamsSchema = z.object({
  params: z.object({
    id: z.string().regex(mongoIdRegex, 'Invalid Session ID format'),
  }),
});

const listSessionsQuerySchema = z.object({
  query: z.object({
    status: z.enum(['pending', 'confirmed', 'completed', 'cancelled']).optional(),
    page: z.preprocess(val => parseInt(val, 10), z.number().int().min(1)).optional(),
    limit: z.preprocess(val => parseInt(val, 10), z.number().int().min(1)).optional(),
    sortBy: z.string().optional(), // e.g., 'datetime:asc' or 'createdAt:desc'
    // Add other filter params like professionalId or seekerId if applicable for admin roles
  }).strict(),
});

const bookSessionSchema = z.object({
  body: z.object({
    professionalId: z.string().regex(mongoIdRegex, 'Invalid Professional ID format'),
    // seekerId will likely come from req.user.id (auth middleware)
    datetime: z.preprocess((arg) => {
      if (typeof arg == "string" || arg instanceof Date) return new Date(arg);
    }, z.date()), // Controller should check if it's a future date and aligns with availability
    duration: z.number().int().min(15, 'Duration must be at least 15 minutes'), // e.g., 30, 45, 60
    // zoomLink might be generated by backend after booking
    // stripeSessionId might be part of a payment flow before or after this
    notes: z.object({
      seeker: z.string().max(1000).optional(),
      // professional notes might be added later by the professional
    }).optional(),
  }).strict(),
});

const updateSessionSchema = z.object({
  params: z.object({
    id: z.string().regex(mongoIdRegex, 'Invalid Session ID format'),
  }),
  body: z.object({
    status: z.enum(['pending', 'confirmed', 'completed', 'cancelled']).optional(),
    datetime: z.preprocess((arg) => {
      if (typeof arg == "string" || arg instanceof Date) return new Date(arg);
    }, z.date()).optional(),
    duration: z.number().int().min(15).optional(),
    zoomLink: z.string().url('Invalid Zoom link').optional().or(z.literal('')),
    notes: z.object({
      seeker: z.string().max(1000).optional(),
      professional: z.string().max(1000).optional(),
    }).deepPartial().optional(), // Allow partial updates to notes
  }).strip(), // Use .strip() to remove unspecified fields, or .strict() to error
});

module.exports = {
  sessionIdParamsSchema,
  listSessionsQuerySchema,
  bookSessionSchema,
  updateSessionSchema,
}; 